name: Docker CI/CD Pipeline

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

# Add permissions for the workflow
permissions:
  contents: read
  checks: write
  pull-requests: write

env:
  IMAGE_NAME: notifications-app
  CONTAINER_NAME: notifications-app

jobs:
  test:
    runs-on: ubuntu-latest
    name: üß™ Test Application
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: üì¶ Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
          
      - name: üîß Make gradlew executable
        run: chmod +x ./gradlew
        working-directory: ./app
        
      - name: üß™ Run tests
        run: ./gradlew test
        working-directory: ./app
        
      - name: üìä Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            app/build/test-results/
            app/build/reports/

      - name: üìã Test Summary
        run: |
          echo "## üß™ Test Results" >> $GITHUB_STEP_SUMMARY
          if [ -f "app/build/test-results/test/TEST-*.xml" ]; then
            echo "‚úÖ Tests completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìÅ Test artifacts uploaded for detailed review." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå No test results found!" >> $GITHUB_STEP_SUMMARY
          fi

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    name: üöÄ Build & Deploy
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: üì¶ Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: üîß Make gradlew executable
        run: chmod +x ./gradlew
        working-directory: ./app

      - name: üèóÔ∏è Build application
        run: ./gradlew clean build -x test
        working-directory: ./app

      - name: üîç Verify JAR and PostgreSQL driver
        run: |
          echo "## üîç Build Verification" >> $GITHUB_STEP_SUMMARY
          echo "üìã Checking built JAR files..." | tee -a $GITHUB_STEP_SUMMARY
          ls -la ./app/build/libs/ | tee -a $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üîç Verifying PostgreSQL driver is included..." | tee -a $GITHUB_STEP_SUMMARY
          if jar tf ./app/build/libs/*.jar | grep postgresql >/dev/null; then
            echo "‚úÖ PostgreSQL driver found in JAR" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå PostgreSQL driver not found in JAR!" | tee -a $GITHUB_STEP_SUMMARY
            echo "üìã JAR contents preview:" | tee -a $GITHUB_STEP_SUMMARY
            jar tf ./app/build/libs/*.jar | head -20 | tee -a $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: üìã Create deployment files
        run: |
          # Create environment file for deployment
          cat > .env << EOF
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          SPRING_PROFILE=production
          EOF
          
          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "üê≥ Starting Docker deployment process..."
          
          # Colors for output
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          RED='\033[0;31m'
          NC='\033[0m'
          
          print_status() { echo -e "${GREEN}[INFO]${NC} $1"; }
          print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
          print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
          
          # Check Docker is available
          if ! command -v docker &> /dev/null; then
              print_error "Docker is not installed!"
              exit 1
          fi
          
          # Set Docker Compose command
          if docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
          else
              DOCKER_COMPOSE="docker-compose"
          fi
          
          print_status "Using: $DOCKER_COMPOSE"
          
          # Stop existing containers gracefully
          print_status "Stopping existing containers..."
          $DOCKER_COMPOSE down --timeout 30 || true
          
          # Clean up old containers and images
          print_status "Cleaning up old resources..."
          docker container prune -f || true
          docker image prune -f || true
          
          # Create backup of database if it exists
          if docker volume ls | grep -q "postgres_data"; then
              print_status "Creating database backup..."
              docker run --rm -v postgres_data:/data -v $(pwd):/backup alpine:latest \
                tar czf /backup/postgres_backup_$(date +%Y%m%d_%H%M%S).tar.gz -C /data . || true
          fi
          
          # Build and start services
          print_status "Building and starting services..."
          $DOCKER_COMPOSE build --no-cache
          $DOCKER_COMPOSE up -d
          
          # Wait for database to be ready
          print_status "Waiting for database to be ready..."
          for i in {1..30}; do
              if docker exec notifications-db pg_isready -U batch_user -d notifications >/dev/null 2>&1; then
                  print_status "Database is ready! ‚úÖ"
                  break
              fi
              echo "Waiting for database... ($i/30)"
              sleep 5
          done
          
          # Wait for application to start
          print_status "Waiting for application to start..."
          for i in {1..36}; do
              if curl -f -s http://localhost:8080/actuator/health >/dev/null 2>&1; then
                  print_status "Application is healthy! ‚úÖ"
                  break
              fi
              echo "Waiting for application... ($i/36)"
              sleep 10
              
              # Show progress every 6 attempts (1 minute)
              if [ $((i % 6)) -eq 0 ]; then
                  print_status "Application logs (last 10 lines):"
                  docker logs notifications-app --tail 10 || true
              fi
          done
          
          # Final health check
          if curl -f -s http://localhost:8080/actuator/health >/dev/null 2>&1; then
              print_status "üéâ Deployment completed successfully!"
              echo "üìä Final status:"
              $DOCKER_COMPOSE ps
              echo ""
              echo "üè• Health check:"
              curl -s http://localhost:8080/actuator/health | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin), indent=2))" || curl -s http://localhost:8080/actuator/health
          else
              print_error "‚ùå Application failed to start properly"
              print_error "üìã Final logs:"
              docker logs notifications-app --tail 50
              exit 1
          fi
          EOF
          
          chmod +x deploy.sh

      - name: üì§ Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          source: "./*"
          target: "~/app/"
          timeout: 120s
          overwrite: true

      - name: üöÄ Deploy to EC2
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          timeout: 300s
          command_timeout: 20m
          script: |
            set -e
            
            echo "üöÄ Starting deployment on EC2..."
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "Deployment time: $(date)"
            
            # Navigate to deployment directory
            cd ~/app
            
            # Show what was copied
            echo "üìÅ Deployment directory contents:"
            ls -la
            
            # Run deployment script
            echo "üèÉ Running deployment script..."
            bash deploy.sh
            
            echo "‚úÖ EC2 deployment completed!"

      - name: üè• Final Health Check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          timeout: 60s
          script: |
            echo "üè• Performing final health checks..."
            
            # Check container status
            cd ~/app
            if docker compose version &> /dev/null; then
                DOCKER_COMPOSE="docker compose"
            else
                DOCKER_COMPOSE="docker-compose"
            fi
            
            echo "üìä Container Status:"
            $DOCKER_COMPOSE ps
            
            echo ""
            echo "üè• Application Health:"
            if curl -f -s http://localhost:8080/actuator/health; then
                echo ""
                echo "‚úÖ Application is healthy and responding!"
            else
                echo "‚ùå Application health check failed"
                exit 1
            fi
            
            echo ""
            echo "üìà Resource Usage:"
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
            echo ""
            echo "üéâ Deployment verification completed successfully!"

      - name: üìä Deployment Summary
        if: always()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.deploy.outcome }}" == "success" ]; then
            echo "‚úÖ **Deployment Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîó **Application URL**: http://${{ secrets.EC2_HOST }}:8080" >> $GITHUB_STEP_SUMMARY
            echo "üè• **Health Check**: http://${{ secrets.EC2_HOST }}:8080/actuator/health" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Deployment completed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment Status**: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for error details." >> $GITHUB_STEP_SUMMARY
          fi

  cleanup:
    needs: [build-and-deploy]
    runs-on: ubuntu-latest
    name: üßπ Cleanup
    if: always() && needs.build-and-deploy.result == 'success'
    
    steps:
      - name: üßπ Cleanup EC2 resources
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          timeout: 60s
          script: |
            echo "üßπ Cleaning up old Docker resources..."
            
            # Remove old backup containers (keep last 3)
            docker ps -a --filter "name=notifications-app-backup" --format "{{.Names}}" | sort -r | tail -n +4 | xargs -r docker rm -f || true
            
            # Clean up unused resources (but keep volumes)
            docker system prune -f || true
            
            # Clean up old backups (keep last 5)
            cd ~/app && ls -t postgres_backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f || true
            
            echo "‚úÖ Cleanup completed!"
