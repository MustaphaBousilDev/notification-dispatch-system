name: CI/CD Pipeline

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          
      - name: Make gradlew executable
        run: chmod +x ./gradlew
        working-directory: ./app
        
      - name: Run tests
        run: ./gradlew test
        working-directory: ./app
        
      - name: Build application
        run: ./gradlew clean build -x test
        working-directory: ./app
        
      - name: Find JAR file
        id: jar
        run: |
          echo "ğŸ” Looking for JAR files..."
          ls -la ./app/build/libs/
          JAR_FILE=$(find ./app/build/libs -name "*.jar" -not -name "*-plain.jar" | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "âŒ No JAR file found!"
            exit 1
          fi
          echo "âœ… Found JAR: $JAR_FILE"
          echo "jar_file=$JAR_FILE" >> $GITHUB_OUTPUT
          echo "jar_name=$(basename $JAR_FILE)" >> $GITHUB_OUTPUT
        
      - name: Deploy to EC2 - Stop Services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          timeout: 60s
          command_timeout: 5m
          script: |
            set -e
            
            echo "ğŸ” System Information:"
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "Available memory:"
            free -h
            echo "Disk space:"
            df -h
            
            echo "â˜• Java version check:"
            java -version 2>&1 || echo "Java not found"
            
            echo "â¹ï¸ Stopping existing application..."
            
            # Check if app.pid exists and stop the process
            if [ -f "/home/deploy/app.pid" ]; then
              OLD_PID=$(cat /home/deploy/app.pid)
              if kill -0 $OLD_PID 2>/dev/null; then
                echo "ğŸ›‘ Stopping application with PID: $OLD_PID"
                kill -TERM $OLD_PID
                sleep 10
                # Force kill if still running
                if kill -0 $OLD_PID 2>/dev/null; then
                  echo "âš¡ Force killing application"
                  kill -KILL $OLD_PID
                fi
              fi
              rm -f /home/deploy/app.pid
            fi
            
            # Stop any remaining Java processes
            pkill -f "java.*\.jar" || echo "No existing JAR process found"
            
            # Kill any process using port 8080
            PORT_PID=$(lsof -ti:8080 2>/dev/null || echo "")
            if [ ! -z "$PORT_PID" ]; then
              echo "ğŸ”Œ Killing process on port 8080: $PORT_PID"
              kill -9 $PORT_PID
            fi
            
            sleep 5
            
            echo "ğŸ’¾ Creating backup..."
            mkdir -p /home/deploy/backups
            if [ -f "/home/deploy/app.jar" ]; then
              BACKUP_FILE="/home/deploy/backups/app-backup-$(date +%Y%m%d-%H%M%S).jar"
              cp /home/deploy/app.jar "$BACKUP_FILE"
              echo "âœ… Backup created: $BACKUP_FILE"
              
              # Keep only last 5 backups
              cd /home/deploy/backups
              ls -t app-backup-*.jar | tail -n +6 | xargs rm -f 2>/dev/null || true
            else
              echo "â„¹ï¸ No existing application to backup"
            fi
            
            echo "ğŸ“ Preparing deployment directory..."
            mkdir -p /home/deploy
            cd /home/deploy
            
            # Clean up old logs
            if [ -f "application.log" ]; then
              mv application.log "application-$(date +%Y%m%d-%H%M%S).log"
            fi
            
            echo "âš™ï¸ Creating application configuration..."
            cat > application.properties << 'EOF'
            # Database Configuration
            spring.datasource.url=jdbc:postgresql://localhost:5432/notifications
            spring.datasource.username=batch_user
            spring.datasource.password=${{ secrets.DB_PASSWORD }}
            spring.datasource.driver-class-name=org.postgresql.Driver
            
            # JPA Configuration
            spring.jpa.hibernate.ddl-auto=update
            spring.jpa.show-sql=false
            spring.jpa.properties.hibernate.format_sql=true
            spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
            
            # Server Configuration
            server.port=8080
            server.servlet.context-path=/
            
            # Actuator Configuration
            management.endpoints.web.exposure.include=health,info,env,metrics
            management.endpoint.health.show-details=always
            management.server.port=8081
            
            # Logging Configuration
            logging.level.root=INFO
            logging.level.org.springframework=INFO
            logging.level.org.springframework.web=DEBUG
            logging.file.name=/home/deploy/application.log
            logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            
            # JVM Configuration
            spring.jpa.open-in-view=false
            EOF
            
            echo "âœ… Configuration created successfully"
            echo "ğŸ“‹ Configuration file contents:"
            cat application.properties | grep -v password
            
      - name: Copy JAR to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          source: ${{ steps.jar.outputs.jar_file }}
          target: /home/deploy/
          timeout: 60s
          debug: false
          overwrite: true
          
      - name: Start Application
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          timeout: 60s
          command_timeout: 10m
          script: |
            set -e
            cd /home/deploy
            
            echo "ğŸ“‹ Checking deployment directory..."
            ls -la /home/deploy/
            
            echo "ğŸ” Looking for JAR file..."
            # Find the uploaded JAR file
            JAR_FILE=$(find /home/deploy -maxdepth 2 -name "*.jar" -not -path "*/backups/*" | head -1)
            
            if [ -z "$JAR_FILE" ]; then
              echo "âŒ No JAR file found in deployment directory!"
              echo "Directory contents:"
              find /home/deploy -type f -name "*.jar" 2>/dev/null || echo "No JAR files found"
              exit 1
            fi
            
            echo "âœ… Found JAR file: $JAR_FILE"
            
            # Rename to app.jar for consistency
            if [ "$(basename $JAR_FILE)" != "app.jar" ]; then
              echo "ğŸ“ Renaming JAR to app.jar..."
              mv "$JAR_FILE" app.jar
            fi
            
            echo "ğŸ“Š JAR file info:"
            ls -lh app.jar
            file app.jar
            
            # Verify JAR integrity
            jar tf app.jar > /dev/null && echo "âœ… JAR file is valid" || {
              echo "âŒ JAR file is corrupted"
              exit 1
            }
            
            echo "ğŸš€ Starting application..."
            
            # Create startup script for better process management
            cat > start_app.sh << 'EOF_SCRIPT'
            #!/bin/bash
            cd /home/deploy
            
            # Set JVM options for better performance
            export JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:+UseStringDeduplication"
            
            # Start the application
            exec java $JAVA_OPTS \
              -jar app.jar \
              --spring.config.location=file:./application.properties \
              --server.port=8080 \
              --logging.file.name=./application.log
            EOF_SCRIPT
            
            chmod +x start_app.sh
            
            # Start the application in background
            nohup ./start_app.sh > startup.log 2>&1 &
            APP_PID=$!
            
            echo "ğŸ“‹ Application started with PID: $APP_PID"
            echo $APP_PID > app.pid
            
            echo "â³ Waiting for application to start..."
            sleep 15
            
            # Check if process is still running
            if ! kill -0 $APP_PID 2>/dev/null; then
              echo "âŒ Application process died immediately!"
              echo "ğŸ“‹ Startup logs:"
              cat startup.log 2>/dev/null || echo "No startup log found"
              echo "ğŸ“‹ Application logs:"
              tail -n 50 application.log 2>/dev/null || echo "No application log found"
              exit 1
            fi
            
            # Health check loop
            for i in {1..24}; do
              echo "ğŸ” Health check attempt $i/24 ($(date))..."
              sleep 15
              
              # Check if process is still running
              if ! kill -0 $APP_PID 2>/dev/null; then
                echo "âŒ Application process died during startup!"
                echo "ğŸ“‹ Application logs:"
                tail -n 100 application.log 2>/dev/null || echo "No application log found"
                exit 1
              fi
              
              # Check health endpoint
              if curl -f -m 10 http://localhost:8080/actuator/health 2>/dev/null; then
                echo "âœ… Application started successfully!"
                echo "ğŸ“Š Application health status:"
                curl -s http://localhost:8080/actuator/health | python3 -m json.tool 2>/dev/null || curl -s http://localhost:8080/actuator/health
                echo ""
                echo "ğŸ“Š System resources after startup:"
                free -h
                echo "ğŸ‰ Deployment completed successfully!"
                exit 0
              else
                echo "âŒ› Application not ready yet... (attempt $i/24)"
                if [ $((i % 6)) -eq 0 ]; then
                  echo "ğŸ“‹ Progress check - last 20 lines of log:"
                  tail -n 20 application.log 2>/dev/null || echo "No application log yet"
                fi
              fi
            done
            
            echo "âŒ Application failed to start within 6 minutes"
            echo "ğŸ“‹ Final application logs (last 200 lines):"
            tail -n 200 application.log 2>/dev/null || echo "No application log found"
            echo ""
            echo "ğŸ“‹ Startup logs:"
            cat startup.log 2>/dev/null || echo "No startup log found"
            echo ""
            echo "ğŸ“Š System resources:"
            free -h
            df -h
            echo ""
            echo "ğŸ” Process status:"
            ps aux | grep -E "(java|app)" | grep -v grep
            echo ""
            echo "ğŸŒ Network status:"
            netstat -tulpn | grep :8080 || echo "Port 8080 not in use"
            echo ""
            echo "ğŸ“‚ Directory contents:"
            ls -la /home/deploy/
            exit 1